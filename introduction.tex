\section{Introduction}
\label{SEC:introduction}

Complex systems require automated testing...

The strategy for carrying out this testing must have certain properties in
order to be successful in testing large scale, modern applications...

Reliance on experts and human-in-the-loop strategies don't scale...
[Alvaro]

Reliance on application source code dramatically limits the scope of what
can be tested...

Tool must be usable by the developers that you have on staff........

Even if a tool satisfies the above requirements, its usefulness is
dependant on the quality of its output.  Tools that produce a high number
of false positives are quickly deemed untrustworthy.  A study by ZZZZ as
shown that false positive rates as low as Q\% have a dramatic, negative
impact on developer perceptions of a tool.  \preston{cite}  A similar
finding is supported by current psychological literature.  Individuals tend
to over-emphasize and over-predict statistically rare negative
events.\preston{cite}  Put another way, if a tool leads to a developer
wasting his or her afternoon by reporting a bug that doesn't exist, the
developer is going to mistrust the tool from then on out.

A useful tool must also do a good job of localizing the source of a bug.
Tools that fail to identify (or worse, misidentify) the source of bugs with
sufficient detail can also lead to wasted time and effort.  For example, a
fuzzing tool that only interacts with an application by mutating normal
input may eventually uncover a crash but merely reporting the presence of a
crash-causing input doesn't get the developer very close to identifying and
fixing the responsible block of code.

\preston{This argument feels weak to me}
At the same time, output that is too detailed or low level can prove just
as detrimental to the bug fixing process.  Consider the case where a tool
reports a bug takes place during the execution of code inside a library
compiled without debugging symbols.  If the developer addressing the bug is
unfamiliar with working on disassembled code, identifying the cause of the
bug may be difficult.

In this paper we want to show that CrashSimulator is able to assist
developers of varying skill levels in identifying bugs bugs in real world
applications.  Additionally, we show that CrashSimulator provides value in
mapping the presence of these bugs to the units of code responsibile for
them allowing developers to fix them in a more timely manner.

CrashSimulator's effectiveness comes its ability expose applications to
unusual environmental conditions that can cause problems with an
application's execution.  CrashSimulator's built-in set of anomalous
conditions allows its users to define which conditions to test an
application against allieviating the need for the expert knowledge required
to set up and test an application in the chosen environments.

CrashSimulator also allows application misbehavior to be localized to a
sequence of system calls allowing the true source of a bug to be more
quickly identified easing the process of correcting it.  This is an
advantage over tools that simply indicate the presence of a bug (i.e.  this
input caused a crash)

To validate these claims we conducted a study with ZZZ participants
consisting of Master's computer science students with varying backgrounds
and specializations.  We asked these participants to test existing popular
applications (as ranked by Debian's Popularity Contest) using each of the
tools.  From this work we collected both quantitative results in terms of
numbers of bugs identified and qualitative results about the tools' user
experince through surveys.

The main contributions in this work are as follows:

\begin{enumerate}

\item We illustrate that CrashSimulator is useful and usable by developers
with a wide variety of backgrounds.

\item We show that CrashSimulator allows these developers to find real bugs
in real applications.

% REWORD POINT 3 A BIT
\item We demonstrate that CrashSimulator compares favorably against similar
automated testing tools in the number of bugs found and in user opinion on
usefulness of the tools' output.

\end{enumerate}
