\section{Introduction}
\label{SEC:introduction}

Complex systems require automated testing...

The strategy for carrying out this testing must have certain properties in
order to be successful in testing large scale, modern applications...

Reliance on experts and human-in-the-loop strategies don't scale...
[Alvaro]

Reliance on application source code dramatically limits the scope of what
can be tested...

Tool must be usable by the developers that you have on staff........

Even if a tool satisfies the above requirements, its usefulness is
dependant on the quality of its output...

Tools that produce a high number of false positives are quickly deemed
untrustworthy [CITE THAT ONE PAPER]

Tools that fail to identify (or worse, misidentify) the source of bugs with
sufficient detail lead to wasted time and and effort...  (i.e. Fuzzing
appication inputs can show that a bug is present but cannot identify the
code responsible for the bug.)

A tool that can more specifically map a failure to the responsible code
speed up the bug fixing process...

At the same time,  if output is too detailed developers of varying skill
levels may have trouble utilizing it...

In this paper we want to show that CrashSimulator is able to assist
developers of varying skill levels in identifying bugs bugs in real world
applications.  Additionally, we show that CrashSimulator provides value in
mapping the presence of these bugs to the units of code responsibile for
them allowing developers to fix them in a more timely manner.

CrashSimulator's effectiveness comes its ability expose applications to
unusual environmental conditions that can cause problems with an
application's execution.  CrashSimulator's built-in set of anomalous
conditions allows its users to define which conditions to test an
application against allieviating the need for the expert knowledge required
to set up and test an application in the chosen environments.

CrashSimulator also allows application misbehavior to be localized to a
sequence of system calls allowing the true source of a bug to be more
quickly identified easing the process of correcting it.  This is an
advantage over tools that simply indicate the presence of a bug (i.e.  this
input caused a crash)

To validate these claims we conducted a study with ZZZ participants
consisting of Master's computer science students with varying backgrounds
and specializations.  We asked these participants to test existing popular
applications (as ranked by Debian's Popularity Contest) using each of the
tools.  From this work we collected both quantitative results in terms of
numbers of bugs identified and qualitative results about the tools' user
experince through surveys.

The main contributions in this work are as follows:

\begin{enumerate}

\item We illustrate that CrashSimulator is useful and usable by developers
with a wide variety of backgrounds.

\item We show that CrashSimulator allows these developers to find real bugs
in real applications.

% REWORD POINT 3 A BIT
\item We demonstrate that CrashSimulator compares favorably against similar
automated testing tools in the number of bugs found and in user opinion on
usefulness of the tools' output.

\end{enumerate}
